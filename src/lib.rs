#![no_std]

#[allow(non_upper_case_globals)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(dead_code)]
mod bindings {
	include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

	// posix_memalign does not have a defined symbol
	extern "C" {
		pub fn memalign(alignment: usize, size: usize) -> *mut core::ffi::c_void;
	}

	// This is because the one generated by bindgen uses the wrong size
	#[repr(C, packed)]
	pub struct vision_object_s_t {
		pub signature: u16,
		pub type_: u8,
		pub left_coord: i16,
		pub top_coord: i16,
		pub width: i16,
		pub height: i16,
		pub angle: u16,
		pub x_middle_coord: i16,
		pub y_middle_coord: i16,
	}

	#[repr(C)]
	pub struct screen_touch_status_s_t {
		pub touch_status: u8,
		pub x: i16,
		pub y: i16,
		pub press_count: i32,
		pub release_count: i32,
	}
}

pub use bindings::*;

#[cfg(feature = "global_allocator")]
mod allocator {
	use core::alloc::{GlobalAlloc, Layout};

	// Wrap the newlib's allocator to Rust's global allocator
	struct NewLibAlloc;
	unsafe impl GlobalAlloc for NewLibAlloc {
		unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
			crate::memalign(layout.align(), layout.size()) as _
		}

		unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {
			crate::free(ptr as *mut _)
		}
	}

	#[global_allocator]
	static ALLOC: NewLibAlloc = NewLibAlloc;
}
